// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {FHE, euint64, externalEuint64} from "@fhevm/solidity/lib/FHE.sol";
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

/// @title ObscuraStorage
/// @notice Stores encrypted file metadata on-chain while keeping the symmetric key protected with Zama FHE
contract ObscuraStorage is ZamaEthereumConfig {
    struct FileRecord {
        string fileName;
        string encryptedHash;
        euint64 encryptedKey;
        uint256 timestamp;
    }

    mapping(address => FileRecord[]) private _records;

    event FileStored(address indexed user, uint256 indexed index, string fileName, string encryptedHash, uint256 timestamp);

    /// @notice Save a new encrypted file reference on-chain
    /// @param fileName Original file name shown to the user
    /// @param encryptedHash Hash that was encrypted client-side with the user's symmetric key
    /// @param encryptedKeyHandle Encrypted symmetric key handle produced by the relayer SDK
    /// @param proof Proof for the encrypted input generated by the relayer SDK
    /// @return index Index of the stored record for the sender
    function storeFile(
        string calldata fileName,
        string calldata encryptedHash,
        externalEuint64 encryptedKeyHandle,
        bytes calldata proof
    ) external returns (uint256 index) {
        require(bytes(fileName).length > 0, "File name required");
        require(bytes(encryptedHash).length > 0, "Encrypted hash required");

        euint64 encryptedKey = FHE.fromExternal(encryptedKeyHandle, proof);

        FileRecord memory record = FileRecord({
            fileName: fileName,
            encryptedHash: encryptedHash,
            encryptedKey: encryptedKey,
            timestamp: block.timestamp
        });

        _records[msg.sender].push(record);
        index = _records[msg.sender].length - 1;

        FHE.allowThis(encryptedKey);
        FHE.allow(encryptedKey, msg.sender);

        emit FileStored(msg.sender, index, fileName, encryptedHash, record.timestamp);
    }

    /// @notice Get the number of stored records for a user
    /// @param user Address whose record count is requested
    function getRecordCount(address user) external view returns (uint256) {
        return _records[user].length;
    }

    /// @notice Fetch a single record for a user by index
    /// @param user Record owner
    /// @param index Index inside the owner's list
    function getRecord(address user, uint256 index) external view returns (FileRecord memory) {
        require(index < _records[user].length, "index too high");
        return _records[user][index];
    }

    /// @notice Return all records stored by a given address
    /// @param user Record owner
    function getRecords(address user) external view returns (FileRecord[] memory records) {
        uint256 length = _records[user].length;
        records = new FileRecord[](length);
        for (uint256 i = 0; i < length; i++) {
            FileRecord storage stored = _records[user][i];
            records[i] = FileRecord({
                fileName: stored.fileName,
                encryptedHash: stored.encryptedHash,
                encryptedKey: stored.encryptedKey,
                timestamp: stored.timestamp
            });
        }
    }
}
